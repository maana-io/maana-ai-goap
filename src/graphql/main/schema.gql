type Info {
    id: ID!
    name: String!
    description: String
}

type GoapProblem {
    id: ID!
    variables: [ Variable !]!
    transitions: [ FlattenedTransition !]!
    effects: [ FlattenedEffect !]!
    conditions: [ FlattenedCondition !]!
    variableOrValues: [ VariableOrValue !]!
    initialValues: [ VariableValue !]!
    goals: [ FlattenedCondition !]!
}

type FlattenedTransition {
  id: ID!
  description: String
  conditions: [ID!]!
  action: ID
  effects: [ID!]!
  cost: Float!
}

type FlattenedCondition {
  id: ID!
  variableId: ID!
  comparisonOperator: ID!
  argument: ID!
}

type FlattenedEffect {
  id: ID!
  variableId: ID!
  assignmentOperator: ID!
  argument: ID!
  order: Int!
}

"""
A variable represents an observable of the worldstate.  
"""
type Variable {
    """
    A unique identifier for the variable.  
    """
    id: ID!
    "An optional description of the variable"
    description: String
    """
    The type of scalar values that can be assigned to the variable.
    Must be one of: STRING, INT, BOOLEAN or FLOAT.
    """
    typeOf: String!
    """
    A weighting factor used to compute the weighted distance 
    between two worldstates which contain this variable.  
    This factor can be used to prevent variables with very large
    values from swamping the distance calculation.   If in doubt 
    use a value of 1.0.
    """
    weight: Float!
}

input VariableInput {
  id: ID
  typeOf: String!
  description: String
  weight: Float
}

"""
A 'union' type representing a scalar value that can be 
assigned to a variable.  Exactly one of the optional fields
must be provided.
"""
type VariableValue {
    id: ID!
    STRING: String
    FLOAT: Float
    INT: Int
    BOOLEAN: Boolean
}

input VariableValueInput {
    id: ID!
    STRING: String
    FLOAT: Float
    INT: Int
    BOOLEAN: Boolean
}

"""
A 'union' type representing a scalar value or variable 
that can occur on the right hand side of a effect or 
constraint.
"""
type VariableOrValue {
    id: ID!
    variableId: ID
    STRING: String
    FLOAT: Float
    INT: Int
    BOOLEAN: Boolean
}

input VariableOrValueInput {
    id: ID
    variableId: ID 
    STRING: String
    FLOAT: Float 
    INT: Int 
    BOOLEAN: Boolean
}


"""
An effect is a reassignment of the value associated 
with a variable.   Depending on the type of the variable, 
reassignment may perform logical or arithmetic operations
to combine the previous value with the provided argument.
To be well formed, the variable, operator and argument 
must all have the same type.
"""
type Effect {
    id: ID!
    variableId: ID!
    assignmentOperator: ID!
    argument: VariableOrValue!
    order: Int!
}

input EffectInput {
    id: ID
    variableId: ID!
    assignmentOperator: ID!
    argument: VariableOrValueInput!
    order: Int
}

"""
A condition is a logical expression that must be satisfied
in order for a transition to be enabled.   To be well formed
the variable, operator and argument must all have the same
type.
"""
type Condition {
    id: ID!
    variableId: ID!
    comparisonOperator: ID!
    argument: VariableOrValue!
}

input ConditionInput {
    id: ID 
    variableId: ID!
    comparisonOperator: ID!
    argument: VariableOrValueInput!
}

"""
A transition is a conditional behavior, which may occur
whenever its all its conditions are satisfied by the 
worldstate.   For the purpose of planning, firing the 
transition is assumed to produce a number of effects which 
modify the worldstate.   Optionally it may produce an 
action, which will be returned as part of the optimal 
action plan.
"""
type Transition {
    "A globally unique identifier for the transaction"
    id: ID!
    "An optional description of the transaction"
    description: String
    """
    A collection of conditions that must be satisfied by
    the worldstate in order for the transaction to be 
    enabled. 
    """
    conditions: [ Condition! ]!
    """
    The identifier for an action that should be added to 
    the action plan as a result of the transaction firing.
    """
    action: ID
    """
    A collection of mutations to perform on the worldstate
    variables whenever the transaction fires.
    """
    effects: [ Effect! ]!
    """
    The cost basis of the transaction used for planning 
    purposes. 
    """
    cost: Float!
}

input TransitionInput {
    id: ID!
    description: String
    conditions: [ConditionInput]
    action: ID
    effects: [ EffectInput ]
    cost: Float
}

type ActionPlan {
    id: ID!
    actions: [ ID! ]!
    transitions: [ ID! ]!
    totalSteps: Int!
    totalCost: Float!
    initialState: [VariableValue!]!
    finalState: [VariableValue!]!
    status: String!
}

type Query {
    info: Info!

    """
    What types can be assigned to variables?
    """
    variableTypes: [ID!]!

    """
    Given a type, what are the assignment operators that are defined for variables of that type?
    """
    assignmentOperators( variableType: ID! ): [ID!]!

    """
    Given a type, what are the comparison operations that are defined for variables of that type?
    """
    comparisonOperators( variableType: ID! ): [ID!]!

    """Smart constructor for a single variable.   Will return a value only if it is well formed."""
    createVariable( variables: [VariableInput!]!, id: String!, description: String, typeOf: ID!, weight: Float ): Variable
    
    """Smart constructor for a multiple variables.   Will return values only if all are well formed."""
    createVariables( variables: [VariableInput!]!, newVariables:[VariableInput!]! ): [Variable!]!

    """Smart constructor for a single transition.   Will return a value only if it is well formed."""
    createTransition( variables: [VariableInput!]!, transitions:[TransitionInput], id: String!, description: String, conditions:[ ConditionInput ], effects:[ EffectInput ], action:ID, cost: Float ): Transition

    """Smart constructor for an array of transitions.   Will return a value only if it is well formed."""
    createTransitions( variables: [VariableInput!]!, transitions:[TransitionInput], newTransitions:[TransitionInput!]! ): [Transition!]
    
    """Smart constructor for an effect.   Will return a value only if it is well formed."""
    createEffect( variables:[VariableInput!]!, variableId:String!, operator:ID!, argument: VariableOrValueInput! ): Effect

    """Smart constructor for a single condition.   Will return a value only if it is well formed."""
    createCondition( variables:[VariableInput!]!, variableId:String!, operator:ID!, argument: VariableOrValueInput! ): Condition

    """Smart constructor for a variable value.  Will return a value only if it is well formed."""
    createVariableValue( variables:[VariableInput!]!, id: String!, BOOLEAN: Boolean, INT: Int, FLOAT: Float, STRING: String): VariableValue

    """Smart constructor for a variable or value.  Will return a value only if it is well formed."""
    createVariableOrValue( variables:[VariableInput!]!, id: String!, variableId: ID, BOOLEAN: Boolean, INT: Int, FLOAT: Float, STRING: String): VariableOrValue

    """Smart constructor for initial values.   Will verify each of the provided variable values, remove invalid values, and create default values for any missing variables. """
    createInitialValues( variables:[VariableInput!]!, variableValues:[VariableValueInput]):[VariableValue!]!

    """Smart constructor for a single initial value.   Will verify if the variable exists, and the value is the correct type. """
    createInitialValue( variables:[VariableInput!]!, id: ID!,  BOOLEAN: Boolean, INT: Int, FLOAT: Float, STRING: String):VariableValue!

    """Flatten GOAP Problem so that it can be stored using Q's crud operators"""
    flattenGoapModel( variables:[VariableInput!]!, transitions: [TransitionInput], initialValues:[VariableValueInput], goals:[ ConditionInput] ): GoapProblem!

    """Rename a variable, changing all occurrences of the variable name in a goap problem."""
    updateVariableName( id: ID!, newId: ID!, variables:[VariableInput!]!, transitions: [TransitionInput], initialValues:[VariableValueInput], goals:[ConditionInput]):GoapProblem!
    
    """Change the type of a variable, and replace any values assigned or compared to it with the default values."""
    updateVariableType( id: ID!, typeOf: ID!, variables:[VariableInput!]!, transitions: [TransitionInput], initialValues:[VariableValueInput], goals:[ConditionInput]):GoapProblem!

    """Remove all occurences of a variable from a GOAP problem, replacing its occurence on the right hand side of comparisons or assignments with an approprate default"""
    removeVariable( id: ID!, variables:[VariableInput!]!, transitions: [TransitionInput], initialValues:[VariableValueInput], goals:[ConditionInput]):GoapProblem!

    """Given a collection of goap state variables, a goap state and a transition, return the result of applying the transition."""
    areGoalsSatisfied(variables:[VariableInput!]!, state:[VariableValueInput!]!, goals:[ConditionInput]):Boolean!
    
    """Given a collection of goap state variables, a goap state and a transition, return the result of applying the transition.  Returns null if the transition is not enabled."""
    singleStep(variables:[VariableInput!]!, state:[VariableValueInput!]!, transition:TransitionInput!):[VariableValue!]!

    """Given a goap model and the current state, return the identifiers for the enabled transitions."""
    enabledTransitions(variables:[VariableInput!]!, state:[VariableValueInput!]!, transitions:[TransitionInput!]!):[ID!]!

    """Given a goap problem, return a flattened goap problem containing the values that can be safely deleted"""
    garbageCollect(variables:[VariableInput!]!, transitions:[TransitionInput!]!, state:[VariableOrValueInput!]!, goals:[ConditionInput!]!):GoapProblem!

    """
    Given a collection of variables and transitions, an intial state, and a collection of goal conditions, what is the least
    cost action plan that acheives that goal?
    """
    generateActionPlan( variables: [VariableInput!]!, transitions: [TransitionInput!]!, initialState: [VariableValueInput!]!, goal: [ConditionInput!]! ): ActionPlan!    
}


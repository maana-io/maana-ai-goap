type Info {
    id: ID!
    name: String!
    description: String
}

"""
A property represents an observable of the worldstate.  
"""
type Property {
    """
    A unique identifier for the property.  
    """
    id: ID!
    "An optional description of the property"
    description: String
    """
    The type of scalar values that can be assigned to the property.
    Must be one of: STRING, INT, BOOLEAN or FLOAT.
    """
    typeOf: String!
    """
    A weighting factor used to compute the weighted distance 
    between two worldstates which contain this property.  
    This factor can be used to prevent properties with very large
    values from swamping the distance calculation.   If in doubt 
    use a value of 1.0.
    """
    weight: Float!
}

input PropertyInput {
  id: ID
  typeOf: String!
  description: String
  weight: Float
}

"""
A 'union' type representing a scalar value that can be 
assigned to a property.  Exactly one of the optional fields
must be provided.
"""
type PropertyValue {
    id: ID!
    STRING: String
    FLOAT: Float
    INT: Int
    BOOLEAN: Boolean
}

input PropertyValueInput {
    id: ID!
    STRING: String
    FLOAT: Float
    INT: Int
    BOOLEAN: Boolean
}

"""
A 'union' type representing a scalar value or property 
that can occur on the right hand side of a effect or 
constraint.
"""
type PropertyOrValue {
    id: ID!
    propertyId: ID
    STRING: String
    FLOAT: Float
    INT: Int
    BOOLEAN: Boolean
}

input PropertyOrValueInput {
    id: ID
    propertyId: ID 
    STRING: String
    FLOAT: Float 
    INT: Int 
    BOOLEAN: Boolean
}


"""
An effect is a reassignment of the value associated 
with a property.   Depending on the type of the property, 
reassignment may perform logical or arithmetic operations
to combine the previous value with the provided argument.
To be well formed, the property, operator and argument 
must all have the same type.
"""
type Effect {
    id: ID!
    propertyId: ID!
    assignmentOperator: ID!
    argument: PropertyOrValue!
}

input EffectInput {
    id: ID
    propertyId: ID!
    assignmentOperator: ID!
    argument: PropertyOrValueInput!
}

"""
A condition is a logical expression that must be satisfied
in order for a transition to be enabled.   To be well formed
the property, operator and argument must all have the same
type.
"""
type Condition {
    id: ID!
    propertyId: ID!
    comparisonOperator: ID!
    argument: PropertyOrValue!
}

input ConditionInput {
    id: ID 
    propertyId: ID!
    comparisonOperator: ID!
    argument: PropertyOrValueInput!
}

"""
A transition is a conditional behavior, which may occur
whenever its all its conditions are satisfied by the 
worldstate.   For the purpose of planning, firing the 
transition is assumed to produce a number of effects which 
modify the worldstate.   Optionally it may produce an 
action, which will be returned as part of the optimal 
action plan.
"""
type Transition {
    "A globally unique identifier for the transaction"
    id: ID!
    "An optional description of the transaction"
    description: String
    """
    A collection of conditions that must be satisfied by
    the worldstate in order for the transaction to be 
    enabled. 
    """
    conditions: [ Condition! ]!
    """
    The identifier for an action that should be added to 
    the action plan as a result of the transaction firing.
    """
    action: ID
    """
    A collection of mutations to perform on the worldstate
    properties whenever the transaction fires.
    """
    effects: [ Effect! ]!
    """
    The cost basis of the transaction used for planning 
    purposes. 
    """
    cost: Float!
}

input TransitionInput {
    id: ID!
    description: String
    conditions: [ConditionInput]
    action: ID
    effects: [ EffectInput ]
    cost: Float
}

type ActionPlan {
    id: ID!
    actions: [ ID! ]!
    transitions: [ ID! ]!
    totalSteps: Int!
    totalCost: Float!
    initialState: [PropertyValue!]!
    finalState: [PropertyValue!]!
}

type Query {
    info: Info!

    """
    What types can be assigned to properties?
    """
    propertyTypes: [ID!]!

    """
    Given a type, what are the assignment operators that are defined for properties of that type?
    """
    assignmentOperators( propertyType: ID! ): [ID!]!

    """
    Given a type, what are the comparison operations that are defined for properties of that type?
    """
    comparisonOperators( propertyType: ID! ): [ID!]!

    """Smart constructor for a single property.   Will return a value only if it is well formed."""
    createProperty( properties: [PropertyInput!]!, id: String!, description: String, typeOf: ID!, weight: Float ): Property

    """Smart constructor for a single transition.   Will return a value only if it is well formed."""
    createTransition( properties: [PropertyInput!]!, id: String!, description: String, conditions:[ ConditionInput ], effects:[ EffectInput ], action:ID, cost: Float ): Transition
    
    """Smart constructor for an effect.   Will return a value only if it is well formed."""
    createEffect( properties:[PropertyInput!]!, propertyId:String!, operator:ID!, argument: PropertyOrValueInput! ): Effect

    """Smart constructor for a single condition.   Will return a value only if it is well formed."""
    createCondition( properties:[PropertyInput!]!, propertyId:String!, operator:ID!, argument: PropertyOrValueInput! ): Condition

    """Smart constructor for a property value.  Will return a value only if it is well formed."""
    createPropertyValue( properties:[PropertyInput!]!, id: String!, BOOLEAN: Boolean, INT: Int, FLOAT: Float, STRING: String): PropertyValue

    """Smart constructor for a property or value.  Will return a value only if it is well formed."""
    createPropertyOrValue( properties:[PropertyInput!]!, id: String!, propertyId: ID, BOOLEAN: Boolean, INT: Int, FLOAT: Float, STRING: String): PropertyOrValue

    """Smart constructor initial values.   Will verify each of the provided property values, remove invalid values, and create default values for any missing properties. """
    createInitialValues( properties:[PropertyInput!]!, propertyValues:[PropertyValueInput]):[PropertyValue!]!

    """
    Given a collection of properties and transitions, an intial state, and a collection of goal conditions, what is the least
    cost action plan that acheives that goal?
    """
    generateActionPlan( properties: [PropertyInput!]!, transitions: [TransitionInput!]!, initialState: [PropertyValueInput!]!, goal: [ConditionInput!]! ): ActionPlan!    
}

